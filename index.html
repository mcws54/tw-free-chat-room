<!DOCTYPE html>
<html>
<head>
  <title>跨端必通聊天室（修复连接问题）</title>
  <style>
    body { max-width: 800px; margin: 0 auto; padding: 20px; font-family: Arial; }
    #room-area { margin-bottom: 10px; }
    #chat-box { border: 1px solid #ccc; height: 400px; overflow-y: auto; padding: 10px; margin-bottom: 10px; background: #fafafa; }
    .msg { margin: 8px 0; padding: 10px; border-radius: 6px; max-width: 70%; }
    .my-msg { background: #4CAF50; color: white; margin-left: auto; }
    .other-msg { background: #e5e5e5; color: #333; margin-right: auto; }
    .system-msg { text-align: center; color: #666; font-size: 12px; margin: 5px 0; }
    .nickname { font-size: 12px; margin-bottom: 4px; opacity: 0.8; }
    .time { font-size: 11px; margin-top: 4px; opacity: 0.7; }
    input { padding: 10px; border: 1px solid #ddd; border-radius: 4px; margin-right: 8px; }
    #nickname { width: 140px; }
    #room-id { width: 200px; }
    #message { flex: 1; min-width: 300px; }
    .input-area { display: flex; align-items: center; margin-bottom: 10px; }
    button { padding: 10px 20px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; }
    button:hover { background: #3d8b40; }
  </style>
</head>
<body>
  <h1>跨端必通聊天室（修复连接问题）</h1>
  
  <!-- 房间区域：创建/加入房间 -->
  <div class="input-area" id="room-area">
    <input type="text" id="nickname" placeholder="输入你的昵称">
    <input type="text" id="room-id" placeholder="输入房间号（比如 666）">
    <button onclick="joinRoom()">创建/加入房间</button>
  </div>

  <!-- 聊天区域：默认隐藏，加入房间后显示 -->
  <div id="chat-area" style="display: none;">
    <div id="chat-box"></div>
    <div class="input-area">
      <input type="text" id="message" placeholder="输入消息内容">
      <button onclick="sendMessage()">发送</button>
    </div>
  </div>

  <script>
    let peerConnection;
    let dataChannel;
    const config = {
      iceServers: [
        // 谷歌免费STUN服务器（跨网络必用）
        { urls: "stun:stun.l.google.com:19302" },
        { urls: "stun:stun1.l.google.com:19302" }
      ]
    };
    let nickname = "";
    let roomId = "";
    const chatBox = document.getElementById("chat-box");
    const chatArea = document.getElementById("chat-area");
    const roomArea = document.getElementById("room-area");
    // 公共信令服务器（免费稳定，帮大家匹配房间）
    const SIGNALING_SERVER = "wss://signalhub.turingtms.com";
    let signalingSocket;

    // 1. 加入房间（核心：通过信令服务器匹配对方）
    async function joinRoom() {
      nickname = document.getElementById("nickname").value.trim() || "匿名用户";
      roomId = document.getElementById("room-id").value.trim();
      if (!roomId) {
        alert("房间号不能为空（比如输入 666）");
        return;
      }

      // 显示聊天区域，隐藏房间区域
      chatArea.style.display = "block";
      roomArea.style.display = "none";
      addSystemMsg(`已加入房间 ${roomId}，正在匹配在线用户...`);

      // 连接信令服务器（关键：跨设备/浏览器找对方）
      await connectSignalingServer();
      // 初始化WebRTC连接
      initPeerConnection();
    }

    // 2. 连接公共信令服务器（帮大家传递连接信息）
    async function connectSignalingServer() {
      signalingSocket = new WebSocket(SIGNALING_SERVER);
      return new Promise((resolve) => {
        signalingSocket.onopen = () => {
          addSystemMsg("已连接服务器，等待匹配...");
          // 告诉服务器自己的房间号，让服务器帮忙找队友
          signalingSocket.send(JSON.stringify({
            type: "join",
            roomId: roomId
          }));
          resolve();
        };

        // 接收服务器转发的对方信息（连接关键）
        signalingSocket.onmessage = (e) => {
          const data = JSON.parse(e.data);
          handleSignalingMessage(data);
        };

        signalingSocket.onerror = (err) => {
          addSystemMsg("服务器连接失败，刷新页面重试");
          console.log(err);
        };
      });
    }

    // 3. 处理服务器转发的消息（建立WebRTC连接）
    function handleSignalingMessage(data) {
      switch (data.type) {
        case "offer":
          // 收到对方的连接请求，回复应答
          peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer))
            .then(() => peerConnection.createAnswer())
            .then((answer) => peerConnection.setLocalDescription(answer))
            .then(() => {
              signalingSocket.send(JSON.stringify({
                type: "answer",
                roomId: roomId,
                answer: peerConnection.localDescription
              }));
            });
          break;
        case "answer":
          // 收到对方的应答，确认连接
          peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
          break;
        case "candidate":
          // 收到对方的网络信息，添加到连接中
          peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate))
            .catch(err => console.log("添加候选失败:", err));
          break;
        case "userJoined":
          addSystemMsg("有新用户加入，正在建立连接...");
          // 主动发起连接请求
          createOffer();
          break;
      }
    }

    // 4. 初始化WebRTC连接
    function initPeerConnection() {
      peerConnection = new RTCPeerConnection(config);

      // 创建消息通道（发送文字用）
      dataChannel = peerConnection.createDataChannel("chat");
      dataChannel.onopen = () => {
        addSystemMsg("✅ 连接成功！可以发消息了～");
      };
      dataChannel.onmessage = (e) => {
        // 接收对方消息
        const msg = JSON.parse(e.data);
        showMessage(msg.content, msg.nickname, false, msg.time);
      };
      dataChannel.onclose = () => addSystemMsg("❌ 对方已断开连接");

      // 收集自己的网络信息，通过服务器发给对方
      peerConnection.onicecandidate = (e) => {
        if (e.candidate) {
          signalingSocket.send(JSON.stringify({
            type: "candidate",
            roomId: roomId,
            candidate: e.candidate.toJSON()
          }));
        }
      };

      // 监听对方创建的通道（如果对方先发起连接）
      peerConnection.ondatachannel = (e) => {
        dataChannel = e.channel;
        dataChannel.onmessage = (e) => {
          const msg = JSON.parse(e.data);
          showMessage(msg.content, msg.nickname, false, msg.time);
        };
        dataChannel.onopen = () => addSystemMsg("✅ 连接成功！可以发消息了～");
        dataChannel.onclose = () => addSystemMsg("❌ 对方已断开连接");
      };
    }

    // 5. 发起连接请求
    function createOffer() {
      peerConnection.createOffer()
        .then((offer) => peerConnection.setLocalDescription(offer))
        .then(() => {
          signalingSocket.send(JSON.stringify({
            type: "offer",
            roomId: roomId,
            offer: peerConnection.localDescription
          }));
        });
    }

    // 6. 发送消息（现在连接成功就能发）
    function sendMessage() {
      const content = document.getElementById("message").value.trim();
      if (!content) {
        alert("消息不能为空！");
        return;
      }
      if (!dataChannel || dataChannel.readyState !== "open") {
        alert("连接还没建立好，等提示「连接成功」再发～");
        return;
      }

      const msgData = {
        nickname: nickname,
        content: content,
        time: new Date().toLocaleString()
      };

      // 自己显示消息
      showMessage(content, nickname, true, msgData.time);
      // 发送给对方
      dataChannel.send(JSON.stringify(msgData));

      document.getElementById("message").value = "";
    }

    // 7. 显示消息
    function showMessage(content, sender, isMine, time) {
      const msgDiv = document.createElement("div");
      msgDiv.className = isMine ? "msg my-msg" : "msg other-msg";
      msgDiv.innerHTML = `
        <div class="nickname">${sender}</div>
        <div>${content}</div>
        <div class="time">${time}</div>
      `;
      chatBox.appendChild(msgDiv);
      chatBox.scrollTop = chatBox.scrollHeight;
    }

    // 8. 显示系统消息
    function addSystemMsg(content) {
      const systemDiv = document.createElement("div");
      systemDiv.className = "system-msg";
      systemDiv.textContent = content;
      chatBox.appendChild(systemDiv);
      chatBox.scrollTop = chatBox.scrollHeight;
    }

    // 按回车发送消息
    document.getElementById("message").addEventListener("keypress", (e) => {
      if (e.key === "Enter") sendMessage();
    });

    // 页面关闭时清理连接
    window.onbeforeunload = () => {
      if (peerConnection) peerConnection.close();
      if (signalingSocket) signalingSocket.close();
    };
  </script>
</body>
</html>
